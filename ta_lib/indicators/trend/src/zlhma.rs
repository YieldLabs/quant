use core::prelude::*;

pub fn zlhma(source: &Series<f32>, period: usize, smooth_period: usize) -> Series<f32> {
    let hma = source.smooth(Smooth::HMA, period);

    hma.smooth(Smooth::HMA, smooth_period)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_zlhma() {
        let source = Series::from([
            7.1135, 7.088, 7.112, 7.1205, 7.1195, 7.136, 7.1405, 7.112, 7.1095, 7.1220, 7.1310,
            7.1550, 7.1480, 7.1435, 7.1405, 7.1440, 7.1495, 7.1515, 7.1415, 7.1445, 7.1525, 7.1440,
            7.1370, 7.1305, 7.1375, 7.1250, 7.1190, 7.1135, 7.1280, 7.1220, 7.1230, 7.1225, 7.1180,
            7.1250, 7.1230, 7.1130, 7.1210, 7.13, 7.134, 7.132, 7.116, 7.1235, 7.1645, 7.1565,
            7.1560,
        ]);
        let period = 3;
        let smooth_period = 2;
        let expected = vec![
            0.0, 0.0, 0.0, 7.1295276, 7.1204166, 7.137084, 7.145639, 7.1091666, 7.101055,
            7.1242785, 7.1356115, 7.159471, 7.1533885, 7.139722, 7.1393056, 7.1438065, 7.1512504,
            7.1530538, 7.140639, 7.1419444, 7.15478, 7.1451106, 7.133417, 7.128304, 7.1368594,
            7.125918, 7.1144705, 7.111918, 7.1284165, 7.125667, 7.1206403, 7.123055, 7.117305,
            7.124556, 7.124973, 7.110944, 7.119223, 7.133779, 7.136498, 7.132387, 7.113446,
            7.1199985, 7.172027, 7.1665835, 7.151444,
        ];

        let result: Vec<f32> = zlhma(&source, period, smooth_period).into();

        assert_eq!(result, expected);
    }
}
